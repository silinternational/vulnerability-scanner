const composer = require('./composer')
const docker = require('./docker')
const mem = require('mem')
const npm = require('./npm')
const { request } = require("@octokit/request")

/**
 * Get the base images used in each of the specified Bitbucket repo's
 * Dockerfiles.
 *
 * @param {string} username - A Bitbucket username
 * @param {string} appPassword - A Bitbucket app password
 * @param {string} repo - A Bitbucket repo. Example: "some-owner/some-repo"
 * @returns {Promise<string[]>}
 */
const getDockerBaseImagesOfRepo = async (username, appPassword, repo) => {
  const contentsOfFiles = await getContentsOfFilesByName(
    username,
    appPassword,
    repo,
    'Dockerfile'
  )
  const allBaseImages = []
  for (const contentsOfFile of contentsOfFiles) {
    const fileBaseImages = docker.getBaseImagesFrom(contentsOfFile)
    allBaseImages.push(...fileBaseImages)
  }
  return allBaseImages
}

/**
 * Get the JavaScript dependencies of the specified Bitbucket repo.
 *
 * @param {string} username - A Bitbucket username
 * @param {string} appPassword - A Bitbucket app password
 * @param {string} repo - A Bitbucket repo. Example: "some-owner/some-repo"
 * @returns {Promise<undefined | {name: string, version: string}[]>}
 */
const getJavaScriptDependenciesOfRepo = async (username, appPassword, repo) => {
  const contents = await getContentsOfFileByName(
    username,
    appPassword,
    repo,
    'package-lock.json'
  )
  return npm.getDependenciesFromPackageLock(contents)
}

/**
 * Get the PHP dependencies of the specified Bitbucket repo.
 *
 * @param {string} username - A Bitbucket username
 * @param {string} appPassword - A Bitbucket app password
 * @param {string} repo - A Bitbucket repo. Example: "some-owner/some-repo"
 * @returns {Promise<undefined | {name: string, version: string}[]>}
 */
const getPhpDependenciesOfRepo = async (username, appPassword, repo) => {
  const contents = await getContentsOfFileByName(
    username,
    appPassword,
    repo,
    'composer.lock'
  )
  return composer.getDependenciesFromComposerLock(contents)
}

const getContentsOfFileByName = async (username, appPassword, repo, fileName) => {
  const file = await findFile(username, appPassword, repo, fileName)
  if (file !== undefined) {
    return getContentsOfFileByDownloadUrl(username, appPassword, file.download_url)
  }
  return undefined
}

const getContentsOfFilesByName = async (username, appPassword, repo, fileName) => {
  const files = await findFiles(username, appPassword, repo, fileName)
  return Promise.all(
    files.map(file => getContentsOfFileByDownloadUrl(
      username,
      appPassword,
      file.download_url
    ))
  )
}

const findFile = async (username, appPassword, repo, fileName) => {
  const files = await findFiles(username, appPassword, repo, fileName)
  if (files.length === 1) {
    return files[0]
  } else if (files.length > 1) {
    const filePaths = files.map(file => file.path)
    console.error(`Too many matches found: ${JSON.stringify(filePaths, null, 2)}`)
  }
  return undefined
}

const findFiles = async (username, appPassword, repo, fileName) => {
  const files = await listFilesInRepoUsingCache(username, appPassword, repo)
  return files.filter(file => hasFileName(file.path, fileName))
}

const hasFileName = (filePath, fileName) => {
  return (filePath === fileName) || filePath.endsWith(`/${fileName}`)
}

const listFilesInRepo = async (username, appPassword, repo) => {
  const [workspace, repoSlug] = repo.split('/')
  try {
    const uriEncWorkspace = encodeURIComponent(workspace)
    const uriEncRepoSlug = encodeURIComponent(repoSlug)
    const items = await getAllPagesOfResults(
      username,
      appPassword,
      `repositories/${uriEncWorkspace}/${uriEncRepoSlug}/src`,
      ['values.attributes,values.links.self.href,values.path'],
      '&max_depth=5&q=' + encodeURIComponent(
        `path !~ "vendor/" and type = "commit_file"`
      )
    )
    
    const files = items.filter(isNotASymbolicLink)
    return files.map(file => ({
      download_url: file.links.self.href,
      path: file.path
    }))
  } catch (e) {
    if (e.message.includes('This repository is empty')) {
      console.warn(`Warning: ${e.message}`)
    } else {
      console.error(`Error (${e.status}): ${e.message}`)
      throw e
    }
  }
  return []
}
const listFilesInRepoUsingCache = mem(
  listFilesInRepo,
  { cacheKey: arguments => arguments[2] }
)

/**
 * Useful for filtering lists of entries in a repo to remove symlinks. See
 * https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/src/%7Bcommit%7D/%7Bpath%7D
 *
 * @param {{attributes: string[]}} item
 * @returns {boolean}
 */
const isNotASymbolicLink = item => !item.attributes.some(attribute => attribute === 'link')

const getContentsOfFileByDownloadUrl = async (username, appPassword, downloadUrl) => {
  const response = await request(`GET ${downloadUrl}`, {
    headers: {
      authorization: "Basic " + Buffer.from(`${username}:${appPassword}`).toString('base64'),
    },
  })
  return response.data
}

/**
 * List the Bitbucket repos for the specified workspace that are visible when
 * using the given credentials.
 *
 * @param {string} username - A Bitbucket username
 * @param {string} appPassword - A Bitbucket app password
 * @param {string} workspace - The URL slug for a Bitbucket workspace
 * @returns {Promise<string[]>} - List of repos. Example: ["some-owner/some-repo"]
 */
const listRepos = async (username, appPassword, workspace) => {
  const repos = await getAllPagesOfResults(
    username,
    appPassword,
    `repositories/${encodeURIComponent(workspace)}`,
    ['values.full_name']
  )
  return repos.map(repo => repo.full_name)
}

const getAllPagesOfResults = async (username, appPassword, uriEncodedResourcePath, fields, uriEncExtraQuery = '') => {
  const commaDelimitedFields = fields.join(',') + ',next'
  let url = `https://api.bitbucket.org/2.0/${uriEncodedResourcePath}` +
    `?fields=${encodeURIComponent(commaDelimitedFields)}` +
    `&pagelen=100` + uriEncExtraQuery
  
  const allResults = []
  let page = 0
  const maxPages = 100
  while (url && (page < maxPages)) {
    page++
    const response = await request(`GET ${url}`, {
      headers: {
        authorization: "Basic " + Buffer.from(`${username}:${appPassword}`).toString('base64'),
      },
    })
    url = response.data.next
    const repos = response.data.values
    allResults.push(...repos)
  }
  
  if (page >= maxPages) {
    console.error(
      `Stopped after retrieving ${page} pages of results from Bitbucket. There may be more.`
    )
  }
  
  return allResults
}

module.exports = {
  getDockerBaseImagesOfRepo,
  getJavaScriptDependenciesOfRepo,
  getPhpDependenciesOfRepo,
  listRepos
}
