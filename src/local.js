const assert = require('assert')
const composer = require('./composer')
const docker = require('./docker')
const fs = require('fs').promises
const path = require('path')
const npm = require('./npm')
const { fileNamesOfInterest, assertFileNameIsInListWeSearchFor } = require('./file')

const foldersToExclude = [
  '.git',
  'vendor',
  'node_modules'
]

/**
 * Get the base images used in each of the specified repo's Dockerfiles.
 *
 * @returns {Promise<string[]>}
 */
const getDockerBaseImagesOfRepo = async (directory) => {
  const contentsOfFiles = await getContentsOfFilesByName(directory, 'Dockerfile')
  const allBaseImages = []
  for (const contentsOfFile of contentsOfFiles) {
    const fileBaseImages = docker.getBaseImagesFrom(contentsOfFile)
    allBaseImages.push(...fileBaseImages)
  }
  return allBaseImages
}

/**
 * Get the JavaScript dependencies of the specified repo.
 *
 * @returns {Promise<undefined | {name: string, version: string}[]>}
 */
const getJavaScriptDependenciesOfRepo = async (directory) => {
  const contents = await getContentsOfFileByName(directory, 'package-lock.json')
  return npm.getDependenciesFromPackageLock(contents)
}

/**
 * Get the PHP dependencies of the specified repo.
 *
 * @returns {Promise<undefined | {name: string, version: string}[]>}
 */
const getPhpDependenciesOfRepo = async (directory) => {
  const contents = await getContentsOfFileByName(directory, 'composer.lock')
  return composer.getDependenciesFromComposerLock(contents)
}

const getContentsOfFileByName = async (directory, fileName) => {
  const file = await findFile(directory, fileName)
  let contents = undefined
  try {
    const buff = await fs.readFile(file)
    contents = buff.toString()
  } catch (err) {
    console.error(`Error (${err.status}): ${err.message}`)
  }
  return contents
}

const getContentsOfFilesByName = async (directory, fileName) => {
  const files = await findFiles(directory, fileName)
  return await files.map(async file => {
    try {
      const buff = await fs.readFile(file)
      return buff.toString()
    } catch (err) {
      console.error(`Error (${err.status}): ${err.message}`)
      return undefined
    }
  })
}

const findFile = async (directory, fileName) => {
  const files = await findFiles(directory, fileName)
  if (files.length === 1) {
    return files[0]
  } else if (files.length > 1) {
    const filePaths = files.map(file => file.path)
    console.error(`Too many matches found: ${JSON.stringify(filePaths, null, 2)}`)
  }
  return undefined
}

const findFiles = async (directory, fileName) => {
  assertFileNameIsInListWeSearchFor(fileName)
  const files = await listFilesOfInterestInRepo(directory)
  return files.filter(file => { return hasFileName(file, fileName) })
}

const hasFileName = (filePath, fileName) => {
  return (filePath === fileName) || filePath.endsWith(`/${fileName}`)
}

const listFilesOfInterestInRepo = async (directory) => {
  const result = []
  const items = await fs.readdir(directory, { withFileTypes: true })
  for (const item of items) {
    const name = path.join(directory, item.name)
    if (item.isDirectory() && !foldersToExclude.includes(item.name)) {
      // walk sub dirs
      const files = await listFilesOfInterestInRepo(name)
      result.push(...files)
    } else if (item.isFile() && fileNamesOfInterest.includes(item.name)) {
      // add matching files of interest
      result.push(name)
    }
  }
  return result
}

module.exports = {
  getDockerBaseImagesOfRepo,
  getJavaScriptDependenciesOfRepo,
  getPhpDependenciesOfRepo,
}
