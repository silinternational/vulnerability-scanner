const { graphql } = require("@octokit/graphql")
const { request } = require("@octokit/request")
const composer = require('./composer')
const { getHyphenatedDate } = require('./date')
const mem = require('mem')

const findFile = async (token, repo, fileName, initialPath = '') => {
  const items = await listRepoContents(token, repo, initialPath)
  
  const files = items.filter(item => item.type === 'file')
  for (let i = 0; i < files.length; i++) {
    const file = files[i]
    if (file.name === fileName) {
      return file
    }
  }
  
  const directories = items.filter(item => item.type === 'dir')
  for (let i = 0; i < directories.length; i++) {
    const directory = directories[i]
    const match = findFile(token, repo, fileName, directory.path)
    if (match) {
      return match
    }
  }
  
  return undefined
}

const getContentsOfFileByName = async (token, repo, fileName) => {
  const file = await findFile(token, repo, fileName)
  if (file !== undefined) {
    return getContentsOfFileByDownloadUrl(token, file.download_url)
  }
  return undefined
}


const getContentsOfFileByDownloadUrl = async (token, downloadUrl) => {
  const response = await request(`GET ${downloadUrl}`, {
    headers: {
      authorization: "token " + token,
    },
  })
  return response.data
}

/**
 * Get the dependencies of the specified GitHub repo.
 *
 * @param token A GitHub personal access token
 * @param repo A GitHub repo. Example: "silinternational/vulnerability-scanner"
 * @returns {Promise<{name, version}[]|undefined>}
 */
const getDependenciesOfRepo = async (token, repo) => {
  const contents = await getContentsOfFileByName(
    token,
    repo,
    'composer.lock'
  )
  return composer.getDependenciesFromComposerLock(contents)
}

const getSecurityVulnerabilitiesForPackage = async (token, packageName) => {
  const hyphenatedDate = getHyphenatedDate()
  console.log(`Calling GitHub API for security vulnerabilities for ${packageName}`)
  const data = await graphql({
    query: `query securityVulnerabilities($package: String!) {
      securityVulnerabilities(
        package: $package,
        ecosystem: COMPOSER,
        first: 100,
        orderBy: {field: UPDATED_AT, direction: DESC}
      ) {
        nodes {
          severity
          vulnerableVersionRange
          advisory {
            identifiers {
              type
              value
            }
          }
          package {
            name
          }
        }
      }
    }`,
    package: packageName,
    headers: {
      authorization: "token " + token,
    },
  })
  const vulnerabilities = data.securityVulnerabilities.nodes
  return vulnerabilities.map(vulnerability => ({
    identifiers: listIdentifiers(vulnerability.advisory),
    inspectedOn: hyphenatedDate,
    packageName: vulnerability.package.name,
    vulnerableVersionRange: vulnerability.vulnerableVersionRange,
    severity: vulnerability.severity
  }))
}

/**
 * List the given advisory's identifiers.
 *
 * @param advisory {{ identifiers: [{type,value}] }}
 * @returns {string[]} - Example: ['CVE-1970-00001']
 */
const listIdentifiers = advisory => {
  const identifiers = advisory.identifiers || []
  return identifiers.map(i => i.value)
}

/**
 * Get the security vulnerabilities for the specified PHP library. This will
 * use an in-memory cache to avoid repeated calls for the same library during a
 * single run.
 *
 * @type Function
 * @param token {string} - A GitHub personal access token
 * @param packageName {string} - A Composer/Packagist package name.
 * @returns {Promise<{identifiers, inspectedOn, packageName, vulnerableVersionRange, severity}[]>}
 */
const getSecurityVulnerabilitiesForPackageUsingCache = mem(
  getSecurityVulnerabilitiesForPackage,
  { cacheKey: JSON.stringify }
)

const listRepoContents = async (token, repo, path = '') => {
  const [repoOwner, repoName] = repo.split('/')
  const response = await request(`GET /repos/:repoOwner/:repoName/contents/:path`, {
    headers: {
      authorization: "token " + token,
    },
    path: path,
    repoOwner: repoOwner,
    repoName: repoName,
  })
  const items = response.data
  return items.map(item => ({
    download_url: item.download_url,
    name: item.name,
    path: item.path,
    type: item.type
  }))
}

/**
 * List the GitHub repos for the specified organization that are visible when
 * using the given personal access token.
 *
 * @param {string} org
 * @param {string} token
 * @returns {string[]} - List of repos. Example: ["silinternational/vulnerability-scanner"]
 */
const listRepos = async (org, token) => {
  const response = await request("GET /orgs/:org/repos", {
    headers: {
      authorization: "token " + token,
    },
    org: org,
  })
  const repos = response.data
  return repos.map(repo => repo.full_name)
}

module.exports = {
  getDependenciesOfRepo,
  getSecurityVulnerabilitiesForPackageUsingCache,
  listRepos
}
