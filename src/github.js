const { graphql } = require("@octokit/graphql")
const { request } = require("@octokit/request")
const mem = require('mem')

const findFile = async (token, repo, fileName, initialPath = '') => {
  const items = await listRepoContents(token, repo, initialPath)
  
  const files = items.filter(item => item.type === 'file')
  for (let i = 0; i < files.length; i++) {
    const file = files[i]
    if (file.name === fileName) {
      return file
    }
  }
  
  const directories = items.filter(item => item.type === 'dir')
  for (let i = 0; i < directories.length; i++) {
    const directory = directories[i]
    const match = findFile(token, repo, fileName, directory.path)
    if (match) {
      return match
    }
  }
  
  return undefined
}

const getContentsOfFileByName = async (token, repo, fileName) => {
  const file = await findFile(token, repo, fileName)
  if (file !== undefined) {
    return getContentsOfFileByDownloadUrl(token, file.download_url)
  }
  return undefined
}


const getContentsOfFileByDownloadUrl = async (token, downloadUrl) => {
  const response = await request(`GET ${downloadUrl}`, {
    headers: {
      authorization: "token " + token,
    },
  })
  return response.data
}

/**
 * Get the dependencies of the specified GitHub repo.
 *
 * @param token A GitHub personal access token
 * @param repo A GitHub repo. Example: "silinternational/vulnerability-scanner"
 * @returns {Promise<{name, version}[]|undefined>}
 */
module.exports.getDependenciesOfRepo = async (token, repo) => {
  const contents = await getContentsOfFileByName(
    token,
    repo,
    'composer.lock'
  )
  return composer.getDependenciesFromComposerLock(contents)
}

/**
 * Get our preferred identifier for the given vulnerability (such as a CVE
 * rather than a GitHub-specific identifier, if a CVE is available).
 *
 * @param vulnerability {{advisory: {identifiers: [{type,value}]}}}
 * @returns {string}
 */
module.exports.getPreferredIdentifier = vulnerability => {
  const advisory = vulnerability.advisory || {}
  let identifiers = advisory.identifiers || []
  const cveIdentifiers = identifiers.filter(i => i.type === 'CVE')
  if (cveIdentifiers.length > 0) {
    identifiers = cveIdentifiers
  }
  return identifiers.map(i => i.value).join(', ')
}

const getSecurityVulnerabilitiesForPackage = async (token, packageName) => {
  console.log(`Calling GitHub API for security vulnerabilities for ${packageName}`)
  const data = await graphql({
    query: `query securityVulnerabilities($package: String!) {
      securityVulnerabilities(
        package: $package,
        ecosystem: COMPOSER,
        first: 100,
        orderBy: {field: UPDATED_AT, direction: DESC}
      ) {
        nodes {
          severity
          vulnerableVersionRange
          advisory {
            description
            identifiers {
              type
              value
            }
            permalink
          }
          package {
            name
            ecosystem
          }
        }
      }
    }`,
    package: packageName,
    headers: {
      authorization: "token " + token,
    },
  })
  return data.securityVulnerabilities.nodes
}

/**
 * Get the security vulnerabilities for the specified PHP library. This will
 * use an in-memory cache to avoid repeated calls for the same library during a
 * single run.
 *
 * @type Function
 * @param token {string} - A GitHub personal access token
 * @param packageName {string} - A Composer/Packagist package name.
 * @returns {Promise<{severity, vulnerableVersionRange, advisory, package}[]>}
 */
module.exports.getSecurityVulnerabilitiesForPackageUsingCache = mem(
  getSecurityVulnerabilitiesForPackage,
  { cacheKey: JSON.stringify }
)

const listRepoContents = async (token, repo, path = '') => {
  const [repoOwner, repoName] = repo.split('/')
  const response = await request(`GET /repos/:repoOwner/:repoName/contents/:path`, {
    headers: {
      authorization: "token " + token,
    },
    path: path,
    repoOwner: repoOwner,
    repoName: repoName,
  })
  const items = response.data
  return items.map(item => ({
    download_url: item.download_url,
    name: item.name,
    path: item.path,
    type: item.type
  }))
}

/**
 * List the GitHub repos for the specified organization that are visible when
 * using the given personal access token.
 *
 * @param {string} org
 * @param {string} token
 * @returns {string[]} - List of repos. Example: ["silinternational/vulnerability-scanner"]
 */
module.exports.listRepos = async (org, token) => {
  const response = await request("GET /orgs/:org/repos", {
    headers: {
      authorization: "token " + token,
    },
    org: org,
  })
  const repos = response.data
  return repos.map(repo => repo.full_name)
}
