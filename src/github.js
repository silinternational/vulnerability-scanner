const { graphql } = require("@octokit/graphql")
const { request } = require("@octokit/request")
const composer = require('./composer')
const { getHyphenatedDate } = require('./date')
const mem = require('mem')

const findFile = async (token, repo, fileName, initialPath = '') => {
  const items = await listRepoContents(token, repo, initialPath)
  
  const files = items.filter(item => item.type === 'file')
  for (let i = 0; i < files.length; i++) {
    const file = files[i]
    if (file.name === fileName) {
      return file
    }
  }
  
  const directories = items.filter(item => item.type === 'dir')
  for (let i = 0; i < directories.length; i++) {
    const directory = directories[i]
    const match = findFile(token, repo, fileName, directory.path)
    if (match) {
      return match
    }
  }
  
  return undefined
}

const getContentsOfFileByName = async (token, repo, fileName) => {
  const file = await findFile(token, repo, fileName)
  if (file !== undefined) {
    return getContentsOfFileByDownloadUrl(token, file.download_url)
  }
  return undefined
}


const getContentsOfFileByDownloadUrl = async (token, downloadUrl) => {
  const response = await request(`GET ${downloadUrl}`, {
    headers: {
      authorization: "token " + token,
    },
  })
  return response.data
}

/**
 * Get the dependencies of the specified GitHub repo.
 *
 * @param {string} token - A GitHub personal access token
 * @param {string} repo - A GitHub repo. Example: "silinternational/vulnerability-scanner"
 * @returns {Promise<undefined | {name: string, version: string}[]>}
 */
const getDependenciesOfRepo = async (token, repo) => {
  const contents = await getContentsOfFileByName(
    token,
    repo,
    'composer.lock'
  )
  return composer.getDependenciesFromComposerLock(contents)
}

const getSecurityVulnerabilitiesForPackage = async (token, packageName) => {
  const hyphenatedDate = getHyphenatedDate()
  console.log(`Calling GitHub API for security vulnerabilities for ${packageName}`)
  const data = await graphql({
    query: `query securityVulnerabilities($package: String!) {
      securityVulnerabilities(
        package: $package,
        ecosystem: COMPOSER,
        first: 100,
        orderBy: {field: UPDATED_AT, direction: DESC}
      ) {
        nodes {
          severity
          vulnerableVersionRange
          advisory {
            identifiers {
              type
              value
            }
          }
          package {
            name
          }
        }
      }
    }`,
    package: packageName,
    headers: {
      authorization: "token " + token,
    },
  })
  const vulnerabilities = data.securityVulnerabilities.nodes
  return vulnerabilities.map(vulnerability => ({
    identifiers: listIdentifiers(vulnerability.advisory),
    inspectedOn: hyphenatedDate,
    packageName: vulnerability.package.name,
    severity: vulnerability.severity,
    vulnerableVersionRange: vulnerability.vulnerableVersionRange
  }))
}

/**
 * List the given advisory's identifiers.
 *
 * @param {{ identifiers: [{type,value}] }} advisory
 * @returns {string[]} - Example: ['CVE-1970-00001']
 */
const listIdentifiers = advisory => {
  const identifiers = advisory.identifiers || []
  return identifiers.map(i => i.value).sort()
}

/**
 * Get the security vulnerabilities for the specified PHP library. This will
 * use an in-memory cache to avoid repeated calls for the same library during a
 * single run.
 *
 * @type Function
 * @param {string} token - A GitHub personal access token
 * @param {string} packageName - A Composer/Packagist package name.
 * @returns {Promise<{identifiers, inspectedOn, packageName, severity, vulnerableVersionRange}[]>}
 */
const getSecurityVulnerabilitiesForPackageUsingCache = mem(
  getSecurityVulnerabilitiesForPackage,
  { cacheKey: JSON.stringify }
)

const listRepoContents = async (token, repo, path = '') => {
  const [repoOwner, repoName] = repo.split('/')
  try {
    const response = await request(`GET /repos/:repoOwner/:repoName/contents/:path`, {
      headers: {
        authorization: "token " + token,
      },
      path: path,
      repoOwner: repoOwner,
      repoName: repoName,
    })
    const items = response.data
    return items.map(item => ({
      download_url: item.download_url,
      name: item.name,
      path: item.path,
      type: item.type
    }))
  } catch (e) {
    console.error(`Error: ${e.message}`)
    return []
  }
}

/**
 * List the GitHub repos for the specified organization that are visible when
 * using the given personal access token.
 *
 * @param {string} token - A GitHub personal access token
 * @param {string} org - A GitHub organization's name
 * @returns {string[]} - List of repos. Example: ["silinternational/vulnerability-scanner"]
 */
const listRepos = async (token, org) => {
  const allRepos = []
  const pageSize = 100
  
  let page = 0
  let thereAreMore = true
  while (thereAreMore) {
    page++
    const response = await request("GET /orgs/:org/repos?per_page=:pageSize&page=:page", {
      headers: {
        authorization: "token " + token,
      },
      org: org,
      page: page,
      pageSize: pageSize
    })
    const repos = response.data
    allRepos.push(...repos)
    thereAreMore = (repos.length === pageSize)
  } 
  
  return allRepos.map(repo => repo.full_name)
}

module.exports = {
  getDependenciesOfRepo,
  getSecurityVulnerabilitiesForPackageUsingCache,
  listRepos
}
